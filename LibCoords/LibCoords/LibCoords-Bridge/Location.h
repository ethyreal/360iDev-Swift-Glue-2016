//
//  Location.h
//  LibCoords
//
//  Created by taco on 8/21/16.
//  Copyright Â© 2016 example. All rights reserved.
//

#ifndef Location_h
#define Location_h

#import <Foundation/Foundation.h>

#pragma mark - Error codes (requires SE-0112 to use NS_ENUM_ERROR)
extern NSString* const LibCoordErrorDomain;

typedef NS_ENUM(NSInteger, CoordinateError) {
    CoordinateErrorWrongDimensions,
    CoordinateErrorCantExist
};

#pragma mark - Position wrapper

// These are the tag values generated by Swift, which we can see by inspecting the IR output.
// It makes sense for tag values to be sequential, starting at 0, and writing to an 8-bit aligned
// type with the minimal amount of space to hold all possible tags. Unless you're writing a very crazy
// app with >256 enum cases (which may not even be supported!), this will always just be an 8-bit value.
//
// Still, this was tested by looking at IR/ASM for a function which constructed Position objects or checked their
// tags, and then seeing which associated value was accessed or execution branch was triggered. This is actually
// slightly harder in IR because of how it uses the `phi` directive.
//
// You can look at the IR and ASM for Location.length() which contains a switch evaluating each position tag, to get an idea
// of which values represent what: See Location.ir:620 and Location.s:509
//
// ASM NOTE: The position flag is stored in the %al register, so you'll be looking for `testb $x, %al` instructions where
// 'x' is the numeric value associated with the tag that executes code. Some other helpful detective skills here:
//
// * .C(Bool) does a value check and branches on it. The block associated with it will have a `testb` or `andb`.
// * .B(Double) uses floating-point values. %xmm# registers are used for FP operations; the block associated with it
//   will use these registers.
// * .A(Int) must be the other block, by exhaustion. Note that we convert an Int to a double, so there will be an %xmm#
//   register in this block as well.
//
// FUN EXERCISE: Can you identify which ASM blocks are associated with which Swift cases? Using an x86_64 reference,
// can you figure out which Swift statements compile to which ASM operations?

typedef NS_ENUM(uint8_t, PositionTag) {
    PositionTagA = 0,
    PositionTagB = 1,
    PositionTagC = 2
};

// You might think that there's an alternative here, to store the value as an NSNumber*. If you uncomment the line below
// you'll see "ARC forbids Objective-C objects in union", which is very smart and correct (ARC is not intelligent enough
// to differentiate what actual type is stored in the union, after all.)
//
// Getting around this means adding the `-fno-objc-arc` flag to EVERY file using this type, marking the value as
// `__unsafe_unretained`, using a void* instead, or explicitly using Objective-C++. See the LLVM documentation on
// ARC for the full information:
//
// http://clang.llvm.org/docs/AutomaticReferenceCounting.html
//
// This mapping was determined by looking at IR: Location.ir:23
typedef struct {
    union {
//        NSNumber* value;
        NSInteger A_val;
        double B_val;
        BOOL C_val;
    } value;
    PositionTag tag;
} PositionWrapper;

#pragma mark - Coordinate wrapper

// This is a mapping for a tuple, which is just contiguous 8-bit aligned space. It is unlikely higher optimization
// levels introduce __attribtue__((packed)) since unaligned data is often slower to access and memory is not at a
// premium in userspace. If this attribute *was* introduced, it would be very obvious in the IR for any function
// returning Coordinate because the `align` directive would have a different value.
//
// Again, ARC forbids Objective-C objects in structs for similar reasons (structs are often manually managed heap
// allocations.) The solution to this problem is similar to the above.
//
// This mapping was determined by looking at IR: Location.ir:773 (midpoint() return value)
typedef struct {
    PositionWrapper position;
//    NSNumber* value;
    double value;
} CoordinateWrapper;

#pragma mark - Direct function calls

// Used in an example for our contrived function call. This is just a direct mapping of the tuple type to a contiguous
// data block.
typedef struct {
    NSInteger value_1;
    double value_2;
} ExampleMapping;

// How did we arrive at this signature, even though multiple return values are used in the ASM (%rdx, %xmm0)? Well, because LLVM only
// cares about the fact that it's returning <i64, double>, which is the return type it would have from either C or
// Swift.
//
// Additionally, the talk slides have a 'bug' in them: They mistakenly say that %xmm0 is not a designated return register.
// While it's not, this is because it is an FP register - the behavior of those is *unspecified* in System V's ABI since
// they are not a general-purpose CPU register. LLVM's behavior to translate <i64, double> into the correct integer
// return register %rax, and use the unspecified-purpose FP register %xmm0 to return the other value. This is the
// same *style* of optimization that leads to Swift using %al, %cl, and other 'scratch' registers for 1-byte values.
ExampleMapping _SW_LibCoords_example(double value);

#endif /* Location_h */
